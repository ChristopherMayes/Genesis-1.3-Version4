#include <iostream>
#include <math.h>

#include "DiagBeamHookedDemo.h"
#include "Particle.h"

using namespace std;

extern "C" DiagBeamHookedBase *factory_beamdiag(void)
{
	DiagBeamHookedBase *p = new DiagBeamHookedDemo;

	return(p);
}

extern "C" void destroy_beamdiag(DiagBeamHookedBase *p)
{
	delete p;
}

DiagBeamHookedDemo::DiagBeamHookedDemo() {}
DiagBeamHookedDemo::~DiagBeamHookedDemo() {}

// After calling this function, a copy of returned obj_names should be generated by caller (it might change/become invalid at a later time)
bool DiagBeamHookedDemo::get_infos(DiagBeamHookInfos *pi)
{
	my_obj_names.clear();
	my_obj_names.push_back("xstd");
	my_obj_names.push_back("the_answer");
	pi->obj_names = &my_obj_names;
	pi->info_txt = "Demo for beam plugin diagnostics";

	return(true);
}

void DiagBeamHookedDemo::doit(DiagBeamHookData *pd)
{
	/* ALWAYS AS FIRST STEP: check version of data structure (and if the data layout is what we expect). This crashes the program if there is a mismatch. */
	verify_datastructure(pd);

	if((pd->verbose) && (pd->mpi_rank==0)) {
		cout << "DiagBeamHookedDemo: "
		     << "iz=" << pd->iz
		     << ", is=" << pd->is << endl;
	}

	/* example code: compute stddev in x plane */
	const vector<Particle>& slice = *(pd->datain);
	const int npart = slice.size();
	double xmean=0.;
	for (auto const &pp: slice) {
		xmean += pp.x;
	}
	if(npart>0)
		xmean/=npart;

	double xvar=0., xstd=0.;
	for (auto const &pp: slice) {
		xvar += (pp.x-xmean)*(pp.x-xmean);
	}
	if(npart>0)
		xvar=xvar/npart;

	xstd = sqrt(xvar);

	/* data organization as in the obj_names provided by calling 'get_infos' */
	pd->dataout->at(0) = xstd;
	pd->dataout->at(1) = 42.;
}
